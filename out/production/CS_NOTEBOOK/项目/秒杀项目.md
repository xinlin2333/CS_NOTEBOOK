秒杀项目实现：过滤请求，秒杀商品

注意点：

1、关于docker通信方式的redis集群（link，自定义network）

2、分布式锁

3、redis集群和sentinel高可用

4、布隆过滤器

5、redis秒杀缓存

6、异步写入数据库



**简介**

- 功能：商品抢购秒杀功能
- API：商品秒杀借口
- 数据落地存储方案 通过分布式redis减少库存；DB存最终订单信息的数据
- api性能调优：性能瓶颈在高并发秒杀；超卖问题

步骤梳理

- 利用redis缓存incr拦截流量

  - 首先通过数据控制快，提前讲秒杀商品缓存到读写分离redis，并且设置秒杀开始
  - 秒杀开始亲，服务器集群start= 0，直接返回未开始
  - 服务时间不一致可能导致流量倾斜，所以要有开始标记
  - 数据库秒快将googsld——start为0，直接返回未开始

- 实现（上）

  简介：后端秒杀网关流量阶层开发

  - 先判断秒杀是否已经开始，初始化将key seckill_START_1存入数据库中
  - 利用缓存incr拦截流量：缓存拦截流量编写
  - 通过原子+加判断当前skuld_accesssh是否达到最大值

  思考：是否需要保证获取取到值的时候和incr值两个命令的原子性；（保证原子性的方式，采用lua脚本；   



## api实现（2）

简介：秒杀信息校验层功能并发布隆过滤器实现重复购买拦截

- 订单信息校验
  - 校验当当前用户是否已经买过
  - 粗出数据率太低
  - 存redis value方式数据太小
  - 存布隆过滤器性能高，过滤性强且数据量小

api（3）：

简介：后端秒杀信息校验层高开发

后端秒杀信息校验功能开发lua脚本实现苦笋加增

- 库存扣除成功，获取当前最新库存
- 如果库存大雨0，即立马访问他墙狗给用户
- 考虑原子性（采用lua脚本



返回抢购结果：success。，抢购失败


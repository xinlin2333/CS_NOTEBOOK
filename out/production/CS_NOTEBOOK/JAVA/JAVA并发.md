# 一、进程与线程

## 进程间通信方式

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中看不到，所以进程间要交换数据必须有通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷贝到内核缓冲区，进程B再去内核缓冲区把数据读走

1、匿名管道通信（pipe）

管道是一种半双工的通信，数据只能单向流动，而且只能有亲缘关系的进程间使用（父子进程）

2、高级管道通信

3、有名管道通信

4、消息队列

5、信号量

semophre：信号量是一个计数器，控制多个进程对共享资源的访问；作为一种锁机制，**防止某进程正在访问共享资源**



6、信号

7、共享内存通信

shared memory：映射一段能被其他进程所能访问的内存。共享内存是最快的IPC方式

8、套接字

进程间通信机制

通信过程：

1、命名socket

sock_stream式本地套接字的通信双方均需要具有本地地址，其中服务器端的本地地址需要明确制定，指定方法使用struct sockaddr_un类型的变量

2、socket

sock_stream本地套接字的通信双方均需要具有本地地址，将相应字段赋值，再将其绑定在创建的服务器套接字上，绑定要使用bind系统调用

```java
int bind(int socket,const struct sockaddr *address,size_t address_len);
```

3、监听

服务端等待客户端连接并处理请求，监听使用listen系统调用，接受客户端连接使用accept系统调用

```java
int listen(int socket,int backlog)
int accpet(int socket,struct sockaddr * addr,size_t * address_len)
```

4、连接服务器

客户端创建完毕后





## 线程间通信

线程间的通信目的主要是用于线程同步。线程间通讯可以是同一进程下共有的共享内存,全局变量和静态变量

锁机制：互斥锁，条件变量，读写锁

互斥锁提供了以排他方式防止数据结构被并发修改的方法。

读写锁允许多个线程同时读共享数据，而对写操作是互斥的。

条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

信号机制(Signal)：类似进程间的信号处理

# 二、线程状态转换

## waiting（无限期等待）

## Timed waiting (有限期等待)

Run() &start()

1、start启动线程，实现多线程运行，无需等待run方法题代码执行完毕而直接继续执行

thread.start()方法来启动一个线程，（就需状态）

2、run当作普通方法调用

new thread 错误

a. 每次new Thread新建对象性能差。
b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。
c. 缺乏更多功能，如定时执行、定期执行、线程中断。

thread pool

 a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。
b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。
c. 提供定时执行、定期执行、单线程、并发数控制等功能。

## Java线程和操作系统线程的对应关系


# 一、事务

## 1、概念：
事务指的是满足acid特性的一组操作，支持commit/rollback 事务

## 2、ACID：

1、原子性（automaticity）：事务被视为不可分割的最小单元，事务所有的操作要么成功提交，要么失败

2、一致性（consistency）：数据库在事务操作前后保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果都是相同的；

3、隔离性（isolation）：一个事务在提交修改前，其他事务是不可见的

4、持久性（durability）：事务一旦提交，其所做的修改将保存至数据库，即使系统发生崩溃，事务的执行也不会丢失；

（补充：系统崩溃时，可以使用redo log进行恢复，从而实现持久性。redo log重做日志记录的数据页的物理修改，undo log（回滚日志）记录数据的逻辑修改

## 3、AUTOCOMMIT：

mysql默认自动提交，即不显示使用START TRANSACTION语句来开启一个事务，所以每个查询操作都会被当作一个事务并且自动提交



# 二、并发一致性

背景：在并发背景下， 事务的隔离性很难被保证

## 丢失修改

一个事务的更新操作被另一个事务的更新操作覆盖。



## 读脏数据

在不同事务下，当前事务读到另外的事务的尚未提交的数据；例如，T1修改一个数据但未提交，T2随后读这个数据，如果T1撤销这个修改，那么T2读取的便是脏数据；



## 不可重复读

一个事务内多次读取同一个数据集合，在这个事务尚未完成时，另一个事务也访问了同一个数据集并且做了修改，由于第二个事务的修改，第一个事务的两次读取可能不一致



## 幻影读

一个事务读取某个范围内的数据，另一个事务在这个范围内的数据插入了一条数据，此时读取到的结果和第一次读取的不同。



综上所述：并发性主要是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。



# 三、封锁

## 封锁粒度
封锁粒度：行级锁、表级锁
尽量锁定要修改的那部分数据，而不是所有资源，锁定的范围越小，并发程序越高；但是加锁需要消耗资源（获取锁，释放锁，检查锁状态）都会增加系统的开消，封锁粒度越小，系统开销越大

需要在锁开消和并发程度上做权衡

## 封锁类型
### 1、 读写锁

exclusive （互斥锁）：X写锁

sharing （共享锁）：S读锁

一个事务对数据对象加了X锁，加锁期间其他锁不能对A加任何锁

一个事务对数据对象加了S锁，加锁期间不能修改数据，同时其他事务也可以对该数据对象加S锁

### 2、意向锁

支持多粒度的封锁

在存在表级锁和行级锁的情况下，事务A想对表中的某行数据加锁需要对表A的每一行进行检测（耗时很大）

意向锁在原来的X/S基础上引入IX/IS 

IX/IS是表锁，用来表示一个事务想要在某个数据行上加X锁或者S锁

1. 一个事务在获得某个数据行对象的S锁之前，必须先获得表的LS锁或者更强的锁
2. 一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX



任意IX/IS锁是兼容的，只是表达加锁的意思，而不是真正加锁

### 3、封锁协议

一级封锁协议：事务T要对数据A修改，需要加X锁，直至T结束才释放锁-》解决丢失修改的问题，因为不可能同时有两个事务对同一个数据进行修改

二级封锁协议：在一级的基础上，要求读取A时必须加上S锁，读完立马释放锁-》解决读脏数据问题，因为一个事务在对A进行修改时，是不能再加S锁，所以不会读入数据

三级封锁协议：在二级基础上，要求读取A时必须要加S锁-》解决不可重复读，因为读A时，其他事务不能对A加X锁，避免在读期间数据被修改

### 4、两段锁协议

加锁和解锁分为两个阶段进行；

可串行化调度指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同，串行执行的事务互不干扰，不会影响并发一致性



**mysql隐式和显示锁定**

mysql InnoDB存储引擎采用的是两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有锁在同一时刻释放（隐式锁）

InnboDB使用特定进行加锁：`SELECT ... LOCK in SHARE MODE；SELECT ... FOR UPDATE；`



# 四、隔离级别

read uncommitted：事务中的修改尚未提交，对其他事务也是可见的

read committed：一个事务在提交修改前对其他事务不可见（☑️脏读）

read repeated ：保证在同一个事务中多次读取的数据是一致的（☑️脏读 不可重复读）

serializable：强制事务串行执行，多个事务互不干扰，避免并发一致性问题（☑️（脏读 不可重复读 幻影读）



# 五、多版本并发控制

Muti_version_concurrency_control：是mysql的InnoDB存储引擎实现隔离级别的一种方式，用于实现提交读和可重复读这两种隔离级别。未提交读总是读取到新的数据，要求很低；可串行化需要对所有的读行也加锁，MVCC无法实现

## 基本思想：

实际场景中，读操作往往比写操作多；MVCC利用多版本思想，写操作更新最新的版本快找，而读操作去读旧版本快照没有互斥关系

在MVCC操作（insert、update、delete）会为数据行新增一个版本快照

## 版本号

SYS_ID：每开始一个新的事务，系统版本号就回自动递增

TRX_ID：事务开始时的系统版本号

## Undo日志

MVCC的多版本指的是多版本的快照，快照存储在Undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来。

1、Undolog 是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更就会产生UNDOrecord，默认被记录到系统表空间（ibdata），5.6后使用undo表空间

2、Undo记录中存储的是旧数据，当一个旧的事物要读取数据时，顺着undo链找到满足其可见性的记3录。所以当版本链很长的时候，比较耗时

3、大多数对数据的变更操作，insert在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除；而update/del需要维护版本信息，在innoDB里，这两个操作被归为一类，update_undo

4、回滚段中 insert undo log 和 update undo log

insert undo log ：事务insert新纪录产生的undolog，只在事务回滚时需要，并且在事务提交后就可以立即丢弃

update undo log：事务对记录进行del 和update 产生的log 不仅在事务回滚时需要，一致性也需要。只有当数据库所有的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除



5、InnoDB存储引擎 在数据库每行数据后面添加三个字段

1、6个字节的TRX_ID 表示最近一次对本行记录做修改的事务标识符；对于del操作，更新行中的一个特殊位将行表示为delete，但并非真正删除

2、DB_ROLL_PTR：写入回滚段（rollback segment）的undo logrecord

3、DB_ROW_ID:包含一个随着新行插入而单调递增的行ID，当由InnoDB自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中

（即：表中没有主键或者合适的唯一索引，InnoDB会自动生成聚集索引，但聚集索引会使用ROW_ID的值做主键





例如：在mysql中创建一个表，包含主键id和一个字段x，操作如下；

`INSERT INTO t(id,x)VALUES(2,'a');`

`UPDATE t SET x = 'b' WHERE id=1;`

`UPDATE t SET  x = 'c' WHERE id =1;`

Mysql的autocommit机制，每个操作都会被当成一个事务执行；共涉及到三个事务，快照中除了记录事务版本号和操作之外，还有一个bit记录DEL字段，用于标记是否被删除，这里将DEL操作看成是一个特殊的update操作

## ReadView

mvcc维护了一个ReadView结构，主要包含当前系统未提交的TRX_ID，还有该列表的TRX_ID_MIN，TRX_ID_MAX

SELECT操作室，根据数据行快照的TRX_ID和TRX_ID_MIN和MAX判断数据行快照是否可以使用

TRX_ID<TRX_MIN，该数据行快照是在当前所有未提交的事物之前的更改，可以使用

TRX_ID>TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用

TRX_ID介于两者之间，提交读：如果id在列表中，表示该数据行快照对应的事物还未提交，则该快照不可使用，；否则表示已经提交，可以使用

可重复读：都不可以使用。

在数据行快照不可使用的情况下，需要沿着Undo log的回滚指针ROLL_PTR找到下一个快照，再进行上面的判断



## 快照读&当前读

1、快照读

MVCC的SELECT操作是快照中的数据，不需要进行加锁

2、当前读

MVCC对数据库更改需要加锁，从而读取最新的数据

在SELECT操作时，可以强制指定进行加锁操作

`SELECT * FROM table WHERE ? lock in share mode`

`SELECT * FROM table WHERE ? for update`

# 六、Next-key Locks

mysql InnoDB存储引擎一种锁的实现，解决幻影读；在RR级别下，使用MVCC_+Next_key Locks解决幻影读

## Record Locks

锁定一个记录上的索引（非记录本身）；如果没有索引，InnoDB会自动生成聚簇索引

## Gap Locks

锁定索引之间的间隙，但不包含索引本身

例如：

`SELECT c FROM TABLE WHERE c BETWEEN 10 and 20 FOR UPDATE`

其他事务不能在这个区间插入任何值

## Next-keyLocks

Record key 和 Gap Lock的结合，锁定一个前开后闭区间



# 七、关系数据库设计理论

## 函数依赖

A->B : B 依赖于A

{a1,a2,a3,...,an}是关系的一个或者多个属性的集合，该集合为键码

A中存在真子集 A'->B,A->B为部分依赖

A->B,B->C:传递函数



## 范式

解决冗余异常、修改异常、删除异常、插入异常

1、1NF：属性不可分

2、2NF每个非主属性完全函数依赖于键码

3、3NF：非主属性不传递函数依赖于键码
























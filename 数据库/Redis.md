# 一、概述

Redis 速度非常快的非关系型内存键值数据库，可以存储键和五种不同类型的值之间的映射

redis为单进程单线程模式，采用队列模式将并发访问变为串行访问

键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表，有序集合

# 2、数据类型

| 数据类型    | 值                     | 操作                                                         |
| ----------- | ---------------------- | ------------------------------------------------------------ |
| string      | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作 |
| LIST        | 列表                   | 从两端压入或者弹出元素，对单个或者多个元素进行修剪，只保留一个范围内的元素 |
| SET         | 无序集合               | 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 |
| HASH（map） | 包含键值对的无序散列表 | 添加、获取、移除单个键值对。获取所有键值对 。检查某个键是否存在 |
| ZSET        | 有序集合               | 添加、获取、删除元素。根据分值范围或者成员获取元素 计算一个键的排名 |

## bitmap

通过一个bit位表示某个元素对应的值或者状态，其中key就是对应元素本身（8个bit可以组成一个byte，bitmap本身会极大的节省存储空间



BitMap命令

**SETBIT**：SETBIT key offset value 复杂度：O（1）

对key所存储的值，设置或者清楚指定偏移量上的位（bit）

位的设置或清楚取决于value参数，可以是0或者1

当key不存在时，自动生成一个新的字符串值

字符串会进行伸展（GROWN）以确保它可以将value保存在指定的偏移量上。当字符串进行伸展时，空白位置以0填充

offset参数必须大于或者等于0，<2^ 32（bit映射被限制在512MB之内）

**对使用大的offset的SETBIT操作来说，内存分配可能造成redis服务器被阻塞**

**返回值**：字符串指定偏移量上原来的位（bit）

**底层实现**：long类型数组

应用场景：

1、统计用户在线数目

使用时间作为cachekey，用户id位offset，如果当天活跃过就设置为1，计算某天/月/年的活跃用户：

BITOP operation destkey key [key ...]

说明：对一个或者多个保存二进制的字符串key进行位元操作，并将结果保存到destkey上

BITOP支持AND OR NOT XOR 

2、对十亿数据取top

3、用户签到

# 三、数据结构源码分析

## 1、String

SDS：simple dynamic string ；可以修改；类似于arrayList，有一个字符数组

SDS结构使用泛型定义了好多次，没有用int类型，是因为字符串比较短的时候，len和alloc 可以使用short和byte来表示，Redis为了对内存做极致优化，不同长度的字符串使用不同的结构体来表示



SDS&C字符串

C字符串不满足redis对字符串安全性

效率以及功能方面的要求；C使用了一个长度为N+1的字符数组来表示长度为N的字符串，并且字符数组最后一个元素总是‘\0‘

存在以下问题：

获取字符串长度为o(n)级别的操作，因为c不保存数组的长度，每次都要遍历一遍整个数组；

不能很好的杜绝buffer 溢出问题，如果执行拼接or缩短字符串的操作，在空间不足的情况下，不做扩容，会导致以上问题

c字符串只能保存文本数据



**字符串操作**

过期和SET命令扩展

可以对key设置过期时间，到时间就被自动删除，以此控制缓存的失效时间

SET + EXPIRE =》 SETEX

```c
SETEx key 5 value1
```



**计数**

如果value是一个整数，还可以对他使用INCR进行原子性的自增操作（当多个客户端对同一个key进行操作，也不会导致竞争的情况）

```
SET counter 100
INCR counter
INCRBY counter 50

```

**返回原值的GETSET**

为key设置一个值并返回原值：这对于某一些需要隔一段时间就统计的key很方便设置和查看；例如：系统每当由用户进入的时候用INCR操作一个key，当需要统计的时候可以把这个key使用GETSET命令重新赋值 为0



## 2、list

相当于Java中LinkedList ，不是数组！数组！数组～

因此插入、删除操作非常快；

![截屏2020-07-24 下午6.53.34](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.53.34.png)

![截屏2020-07-24 下午6.52.48](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.52.48.png)

多个listnode通过prev和next指针组成双向链表

![截屏2020-07-24 下午6.54.30](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.54.30.png)

LPUSH和RPUSH 分别向list的左边和右边添加一个元素

LRANGE从list中取出一定范围的元素

LINDEX从list中取出指定下表的元素

**![截屏2020-07-24 下午6.56.47](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.56.47.png)**



list实现队列

队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，确保元素的访问顺序

![截屏2020-07-24 下午6.59.08](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.59.08.png)

list实现栈



## 3、字典哈希

相当于Java中的HashMap。数组+链表的链地址发解决哈希冲突

![截屏2020-07-24 下午7.08.21](/Users/yangxinlin/Desktop/截屏2020-07-24 下午7.08.21.png)

table属性是一个数组，数组中每个元素都是指向一个指针

![截屏2020-07-25 上午1.10.31](/Users/yangxinlin/Desktop/截屏2020-07-25 上午1.10.31.png)

字典结构中包含两个hashtable ，但是只有一个是有值的，第二个字典扩容缩荣时，会进行**渐进式搬迁**

**渐进式rehash**

大字典式的扩容比较耗时，需要重新申请新的数组，然后将旧字典所有的链表中的元素重新挂到新的数组下面，这是一个o(n)级别的操作，作为单线程的redis很难承受这样耗时的过程，所以redis使用渐进式rehash小步搬迁：

![截屏2020-07-25 上午1.17.02](/Users/yangxinlin/Desktop/截屏2020-07-25 上午1.17.02.png)

渐进式rehash在rehash同时保留新旧两个hash结构，查询时会同时查询两个hash结构，然后在后续的定时任务以及hash操作指令中，循序渐进的把旧字典的内容迁移到新字典中



**扩缩荣的条件**

正常情况下，当hash表中元素的个数等于第一维数组的长度，就会开始扩容，扩容的新数组是原数组大小的2倍。不过如果redis正在做bgsave（持久化命令），为了减少内存的也得过多分离，redis尽量不去扩容，但是hash非常满了，达到了第一维数组的5倍了，就会强制扩容



当hash表因为元素主键稀疏，redis对hash表进行缩容来减少hash表的第一维数组空间占用。所用的条件是元素个数低于数组长度的10%，缩容不会考虑redis是否在做bgsave

## 4、集合

相当于Java的hashset，内部的键值对是无序、唯一的，内部实现相当于一个特殊的字典，字典中所有value都是一个值null

## 5、有序列表zset

类似于Java的sortedSet 和hashMap的结合体，一方面它是一个set，保证了内部value的唯一性，另一方面可以为每个value赋予一个score值，用来代表排序的权重

内部实现用的是 **跳跃表**

跳跃表基于多指针有序链表实现的，可以看成多个有序链表；

在查找时，从上层指针开始查找，找到对应区间之后到下一层查找

跳跃表&红黑树：

插入速度非常快速，因为不需要进行旋转等操作

更容易实现；

支持无所操作

# 4、使用场景

## 4.1计数器

可以对string进行自增自减运算，从而实现计数器功能；

redis读写性能非常高，适合存储频繁读写的技术量

## 4.2缓存

将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率

## 4.3 查找表

DNS记录适合使用redis进行存储；查找表和缓存类似，利用redis快速的查找特性；但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源

## 4.4 消息队列

list是一个双向的链表，可以通lpush和rpop写入读取消息；但是最好是消息中间件

## 4.5 会话缓存

使用redis统一存储多台应用服务器的会化信息

## 4.6 分布式锁实现

在分布式场景中，无法使用单机环境下的锁来对多个节点上的进程进行同步，可以使用redis自带的SETNX实现分布式锁（也可以使用redlock分布式锁实现）

## 4.7 其他

set可以实现交集、并集，实现共同好友功能

zset可实现有序行操作，实现排行榜功能

# 5、redis&memached

## 5.1 数据类型

memached仅支持字符串类型的[k,v]，而redis支持五种不同的类型

## 5.2 数据持久化

redis支持两种持久化策略：RDB快照和AOF日志，RDB属于全量备份数据；AOF：append only if ，增量持久化备份，备份的是指令

memacached 不支持持久化

## 5.3 分布式

memacached不支持分布式，只能通过在客户端使用**一致性哈希**来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点

## 5.4 内存管理机制

redis不是所有数据都一直存在内存中，可以将一些很久没用的value交换到磁盘，而memacached的数据则一直在内存中

memacached将内存分割成特定长度的块存储数据，以完全解决内存碎片问题，但是这种方式使得内存的利用率不高；而redis直接申请分配内存，会产生内存碎片

## 5.5 缓存过期机制

memacached在删除失效主键时采用消极的方法，即memcached内部不会监视主键是否失效，而是在通过get访问主键时才会检查其是否已经失效

redis定时、定期等多种缓存失效机制，减少内存泄漏

# 6、数据淘汰策略（保存数据都是热数据）

可以先设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略

| 策略            | 描述                                                 |
| --------------- | ---------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| volatile-ttl    | 从已设置过期时间的数据集中挑选要过期的数据淘汰       |
| volatile-random | 从已设置过期时间数据集中任意选择数据                 |
| allkeys-lru     | 从所有数据集中挑选最近最少使用的数据淘汰             |
| allkeys-random  | 从所有数据集中任意选择                               |
| noeviction      | 禁止驱逐数据                                         |

Redis4.0引入volatile-lfu和allkeys-lfu，**LFU策略通过统计访问频率，将访问频率最少的键值对淘汰**

作为内存数据库，出于对性能和内存消耗的考虑，redis的淘汰算法实际上并非针对所有key是抽样一小部分并且从中选出被淘汰的key

使用redis缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据，可以将内存最大使用量设置为热点数据占用的内存量，然后启用allkeys-lru淘汰策略，将最近最少用的数据淘汰



## redis过期key清除策略

1、redis如何淘汰过期的keys：`set name daniel 3600`

​     **惰性删除**：

​        概念：当一些客户端尝试访问时，key会被发现并主动的过期

​        放任键过期不管，但是每次从键空间获取键时，都会检查是否过期

​       特点：CPU友好，但如果一个key不再使用，那么他会一直存在于内存中，造成浪费

​     **定时删除**：

​         概念：设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作

​     **定期删除**：

​          隔一段时间，程序对数据库进行一次检查，删除里面的过期键，至于要删除多少键，检查多少数据库，由算法决定。即设置一个定时任务，间隔小则占用CPU，间隔大则浪费内存

redis服务器实际使用的是惰性删除和定期删除，合理使用CPU时间和避免内存空间浪费

惰性删除策略：expireNeeded函数，操作key的时候进行判断key

定期删除策略：activeExpireCycle函数，serverCron函数执行时，activeExpireCycle函数会被调用，规定的时间里面分多次遍历服务器的expires字典随机检查一部分key的过期时间



清楚过期时间

生存时间可以通过使用DEL来删除整个key来移除，或者被SET和GETSET命令覆盖原来的数据，修改key对应的value和使用另外相同的key和value来覆盖以后，数据的生存时间不同

# 7、持久化

为了保证数据在断电后不会丢失，需要讲内存中的数据持久化到硬盘上

## 7.1 RDB持久化

RDB文件是一个压缩的**二进制文件**，通过该文件还原RDB文件时的数据库状态

有两个命令可以生成RDB文件：SAVE、BGSAVE

区别：

SAVE：阻塞redis服务器进程，知道RDB文件创建完毕为止。而在服务器进程阻塞期间，服务器不能处理任何命令请求的。后者则不会阻塞服务器进程，通过fork一个字进程，并让其去创建RDB文件，而服务器进程继续处理命令请求

当写完后新的RDB会替换旧的RDB

所以我们一般选用BGSAVE来持久化

在rediscover的配置文件，有提供设置服务器每隔多久时间来执行BGSAVE命令

​    *在redis中RDB持久化触发，手动和定时

​    *自动触发：1、save m n 配置规则自动触发；

​                          2、从节点全量复制时，主节点发送RDB文件给从节点完成复制操作，主节点会触发BGSAVE；

​                          3、执行 debug reload时

​                          4、执行shutdown，如果没有开启AOF，也会触发

**RDB的BGSAVE很占用内存**

rdb快照持久化，的时候，fork出来进行dump操作的字进程会占用与父进程一样的内存，真正的copy-on-write对性能的影响和内存的耗用都是比较大的



**RDB原理**

父进程fork（）一个子进程来进行数据备份

fork（）与exec的区别

当前进程调用fork（），会创建一个跟当前进程完全相同的字进程，所以字进程同样是会执行fork（）之后的代码

exec函数的作用：装载一个新的程序 覆盖当前进程

内存空间中的映像，从而执行不同的任务，exec系列函数在执行时会直接替换掉当前进程的地址空间



fork创建出的子进程，与父进程共享内存空间。如果子进程不对内存空间进行写入操作，内存空间中的数据不会复制给子进程，这样创建子进程速度就很快（**不用复制，直接饮用父进程物理空间**）

**写时复制原理**

fork（）之后，kernel把父进程中所有内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当其中某个进程写内存时，CPU硬件检测到内存页是read-only，于是触发了page-fault，陷入kernel的一个中断。中断中，kernel会把触发的异常的页复制一份，于是父子进程各自持有一份

COPY ON WRITE：

减少分配和复制大量资源时带来的瞬间时延

减少不必要的资源分配。

缺点：如果在fork之后，父子进程都需要继续进行写操作，那么会产生大量的分页错误



## 7.2 AOF持久化

将写命令添加到APPEND ONLY FILE末尾

使用AOF持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由OS决定何时同步到磁盘上

| 选项     | 同步频率         | 备注                                                         |
| -------- | ---------------- | ------------------------------------------------------------ |
| always   | 每个写命令都同步 | 严中减低服务器的性能                                         |
| everysec | 每秒同步         | 保证系统崩溃时只会丢失一秒左右的数据，并且redis每秒执行一次同步对服务器的性能没有太大影响 |
| no       | 让操作系统决定   | 没有提升，只会增加系统崩溃时数据丢失的数量                   |

​    **AOF重写**

随着服务器请求增多，AOF文件会比单啊，AOF重写能去除文件中冗余写命令

步骤：命令追加、文件写入、文件同步

命令追加：将写命令追加到AOF缓冲区的末尾

文件写入：缓冲区写到AOF文件，文件写入是将AOF文件保存到磁盘

因为服务器在处理文件事件时，可能会发生写操作，使得一些内容会被追加到AOF缓冲区末尾，所以，在服务器每次结束一个事件循环之前，都会调用FlushAppendOnlyFile方法

（write：根据条件，将缓冲区内容写入到AOF文件

save：根据条件调用FSYNC或者fdatasync函数，将AOF文件保存到磁盘上

这些条件由配置文件中的appendsync选项来决定，1、appendfsync always：每执行一个命令保存一次

2、appendfsync everysec 

3、appendfsync no：不保存（可能是缓存已经被写满，或者定期保存操作被执行，完成依赖OS的写入，一般为30s左右



## AOF重写

1、保存数据的状态差异，导致命令可以重写

2、子进程重写过程中，父进程创建重写缓冲区，子进程重写完成在副驾上重写缓冲区的内容，形成新文件

新文件会代替旧文件，并且两个文件所有保存的数据库状态一样，但是新文件不会包含任何冗余命令

因为重写涉及到大量IO操作，所以redis是用子进程来实现这个功能的，否则将阻塞主进程，该子进程拥有父进程的数据副本，可以避免使用锁的情况下，保证数据的安全性。

注意：子进程重写的过程中，服务器还是会继续处理命令请求，新命令会对数据库进行修改，这会导致当前数据库状态和重写后的AOF文件，所保存的数据库状态不一致

**因此：**redis设置了一个AOF重写缓冲区，在子进程执行AOF重写期间，主进程需要执行以下三个步骤：1、执行客户端的请求命令

2、执行后的写命令追加到AOF缓冲区

3、执行后的写命令追加到AOF重写缓冲区

当子进程结束重写后，会向主进程发送一个信号，主进程接收到之后会调用信号处理函数1、将AOF重写缓冲区内容写入新的AOF文件中。此时新文件所保存的数据库状态和当前数据库状态一致 2、对新文件进行改名，原子地覆盖现有AOF文件，完成新旧文件的替换



## 7.3 redis持久化两种方案对比

注意：**master 上不做持久化，保证读写性能，slave上则同时开启snapshot和AOF来进行持久化，保证数据的安全性**

redis提供了不同的持久性选项：

​     **RDB持久性**以指定的时间间隔执行数据集的时间点快照

​    **AOF持久性**记录服务器接收的每个写入操作，将在服务器启动时再次播放，重建原始数据集。使用与redis协议本身相同的格式以仅追加方式记录命令。当redis太大时，redis能够重写日志背景

|      | AOF                                                          | RDB                                                          |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 1、RDB最大限度地提高了redis的性能，父进程不需要参与磁盘i/o，而是fork出一个子进程来备份； 2、与AOF相比，RDB允许使用最大数据集更快地重启 | 1、性能小好小 2、可以追加命令，比如flushall，只需要停机把aof末尾的命令删除 3、AOF日志更易于理解 |
| 缺点 | 1、在redis停止工作时，将数据丢失的可能性降至最低，则RDB并不好，因为备份时间长，备份数量大 | 1、AOF文件通常比同一个数据集的等效RDB文件大  2、根据确切的fsync策略，AOF可能比RDB慢 |

对于持久化的选择，一般想达到与postgreSQL的数据安全性，需要同时用两种持久化功能；如果非常关心数据，并且能够承受分钟以内的数据丢失，可以使用RDB持久化。有很多用户都只使用AOF持久化；生成RDB快照比AOF恢复的速度要快

所以可以 将RDB和AOF持久化同步使用，自己制定策略定期检查redis情况，可以手动触发备份、重写数据；采用集群和主从同步



# 8、事务

一个事务包含多个命令，服务器在执行事务期间，不会去改执行其他客户端的命令请求；

事务中的多个命令被一次性发送给服务器，（流水线）减少客户端和服务器之间的网络通信次数从而提升性能

redis最简单的事物实现方式：使用MULTI和EXEC 命令将事务操作包围起来

## 8.1 redis事务相关命令

1、MULTI与EXEC以MULTI开始一个事务，然后将多个命令入队到事务中，最后由EXEC命令出发事务，一并执行事务中的所有命令

2、DISCARD取消一个事务，清空客户端的整个事务队列，将客户端从事务状态调整回非事务状态，最后返回ok给客户端

3、WATCH用于食物开始之前的监视任意数量的键；当调用EXEC命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不再执行，直接返回失败



## 8.2 redis事务与传统关系型事务比较

1、原子性

单个redis命令的执行是原子性的，但是redis没有在事务上增加任何维持原子性的机制-《》redis事务的执行不是原子性的；

redis服务器进程在执行事务的过程中被停止，或者命令执行错误，那么剩余命令会继续执行，同时不提供回滚

通过内置的lua解释器，可使用EVAL对lua脚本进行求值。redis使用单个lua解释器去运行所有脚本，并且，redis保证脚本会以原子性方式执行：当某个脚本正在运行的时候，不会有其他的脚本或者redis命令被执行。

2、一致性

redis一致性问题可以分为：入队错误，执行错误，redis进程被终结

**入队错误**

在命令入队过程中，如果客户端向服务器发送了错误的命令，服务器会向客户端返回一个出错信息，并且将客户端的事务状态设置为REDIS_DIRTY_EXEC

当客户端执行EXEC，redis拒绝执行状态为REDIS_DIRTY_EXEC 的事务，并且返回失败信息

**执行错误**

命令在事务执行的过程中发生错误，比如说，对一个不同类型的key执行了错误的操作，那么redis只会将错误包含在事务的结果中，不会引起事务中断或者整个失败

**redis进程被终结**

如果进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么redis所用的持久化模式会出现：

内存模式：如果redis没有采取任何持久化机制，那么重启之后的数据库总是空白的

RDB模式：在执行事务时，redis不会中断事务去执行保存RDB，只有在事务执行后保存RDB的工作才会开始。当RDB模式下的redis服务器进程在事务中途被杀死，事务内执行的命令，不管成功了多少，都不会被保存早RDB中。恢复数据库需要使用现在有的RDB文件，而这个RDB文件的数据保存的是最近一次的数据库快照，还原后数据库是一致的

AOF模式：保存AOF文件的工作在后台线程进行，所以即使是在事务执行的中途，保存AOF文件的工作也可以继续进行

1）如果事务语句未写入到AOF文件，或者AOF未被SYNC调用保存到磁盘，那么当进程被杀死后，redis可以根据最近一次保存成功的文件来还愿数据库

2）如果部分被写入AOF文件，并且AOF文件被成功保存，那么不完整的事务执行信息就会遗留在AOF文件里，当重启redis时，程序会检测到AOF文件并不完整，redis会退出，报告错误，需要使用redis-check-aof工具将部分成功的事务命令



### 8.2.3 隔离性

redis是单进程程序，保证在执行事务时，不会对事务进行中断



### 8.2.4 持久性

事务的持久性由redis的持久化模式决定

在单纯的内存模式下，事务是不持久的

RDB模式下，服务器可能在事务执行之后，RDB文件更新之前失败，RDB模式也是不持久的

AOF模式（总是SYNC）事务的每条命令在执行成功后，都会立即调用fsync 或者fdatasync将事务数据写到AOF文件，但是，这种保存是由后台进程进行，祝线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还有一段小的间隔，所以这种模式下的事务也是不持久的

# 10、redis主从集群的单肩 与docker

## 10.1 docker network 5种网络驱动模式

bridge：默认网络驱动模式，当应用程序运行在需要通信的独立容器（Standalone container），会选择bridge模式

host：移除容器和docker宿主机之间的网络隔离，并直接使用主机的网络

overlay：将多个docker守护进程连接在一起，并使集群服务能够相互通信，或者不同docker守护进程上的两个独立容器之间的通信。实现了容器之间进行操作系统级别路由的需求。

macvlan：macvlan允许为容器分配mac地址，使其显示为网络上的物理设备。docker守护进程通过其Mac地址将流量路由到容器

none：禁止所有联网

# 11、订阅机制

PUBLISH：将message 发送到指定的频道channel，返回收到消息的客户端数量

SUBSCRIBE：订阅给指定频道的信息

UNSUBSCRIBE取消订阅

11.1 redis & mq

redis发布订阅功能比较薄弱但比较轻量级，mq消息持久化，数据可靠性差，无后台功能可以进行消息查询

# 12、redis 二级缓存

## 12.1 实现

先访问redis是否存在，不存在就去mysql查询，并且放入缓存

常用注解：

@CacheConfig（cacheNames="userInfoCache") 在同个redis里面必须唯一

@Cacheable（查）

@CachePut（修改，增加）：当需要更新缓存而不干扰方法执行时，可以使用@CachePut注释，始终执行该方法并将其结果放入缓存中

@CacheEvict：对于从缓存中删除陈旧或者未使用的数据非常有用，指示缓存范围之内的驱逐

## 12.2 springboot cache自定义项

keyGenerator cacheManager（设置缓存过期时间）

自定义序列化方式，Jackson

# 13、缓存雪崩与缓存穿透

13.1 缓存穿透

用户查询的数据在数据库咩有。那么用户查询的时候，在缓存中找不到对应的key的value，每次都要去数据库再查一遍，然后返回空。

解决方案：

1、缓存空值，如果一个查询返回的数据为空（不管数据不存在，还是系统故障）仍然把这个空节点进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个设置的默认值存放到缓存，这样二次到缓存中获取就有值

2、采用BloomFilter 优势占用内存空间小，bit存储。性能特别高

将所有可能存在的数据哈希到一个足够大的bitmap，一个一定不存在的数据会被这个bitmap拦截掉，从而避免对底层存储系统的查询压力



## 13.2 缓存雪崩

如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩

由于原有缓存失效，新缓存未到期所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，甚至可能会宕机



解决方案：

1、加锁排队

key：whitelist 

value：1000w个uid

指定setNxwhitelist value nullvalue

mutex互斥锁解决，redis的SETNX去set一个mutex key

2、数据预热

系统上线后，将相关的缓存数据直接加载到缓存系统。避免在用户请的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先预热的缓存数据

通过reload缓存机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key

3、双层缓存策略

Cache1 位原始缓存，cache2为拷贝缓存，cache1失效，访问cache2

4、定时更新缓存策略

时效性要求不高，容器启动初始化加载，采用定时任务更新或者移除缓存

5、设置不同的过期时间

# 14、redis实现分布式锁（解决不同客户端并发操作某个数据）

## 14.1概念

- 控制分布式系统或者不同系统之间共同访问共享资源的一种锁实现

- 目的：为了保证在分布式部署的应用集群中，同一个方法在同一个操作智能呗一台机器上的一个线程执行

- 设计要求

  这把锁为可重入锁（避免死锁）

  高可用的获取锁和释放锁

  性能高



14.2 分布式锁实现方案

- 获取锁的时候，使用setnx（SETNX key val：当且仅当key不存在的时候，set一个key为val的字符串，返回1；
- 若key存在，返回0枷锁，锁的value值为当前占有锁服务器的内网ip编号拼接任务表识
- 在释放锁的时候进行判断，并且使用expire为锁添加一个超时时间，超过该时间则自动释放锁



### 14.2.1 面试题

1、什么是分布式锁

分布式锁：互斥性、不会发生死锁、加锁解锁是同一个客户端

redis通过内置Lua解释器，使用EVAL命令对Lua脚本进行求值；

redis使用单个Lua解释器运行所有脚本，保证原子性

2、实现分布式锁

lua解释器；

setnx，setex连用

3、解锁注意点

同一个客户端



# 15、redis高可用集群

## 15.1主从复制

主从服务器的数据库保存相同的数据-》数据库状态一致

SYNC：（旧版复制功能）

主服务器执行BGSAVE生成RDB文件，会耗费主服务器大量的CPU、内存和磁盘读写资源

主服务器将RDB文件发送从服务器，耗费主从服务器大量的网络贷款和流量

请求的时间：接收到RDB文件的从服务器在载入文件的过程是阻塞的

PSYNC：

full resynchronsization & partial resynchronization

partial resynchronization ：include ：主服务的replication offset（复制偏移量）和从服务器的复制偏移量

主服务器的复制积压缓冲区（replication backlog）

服务器的ID，因为如果服务器发生异常后，重新运行会判断id，确认部分重同步还是执行完冲同步



## 15.2 分布式系统高可用

高可用：HA high availability，减少系统不能提供服务的时间

**经典架构环节分析**

- **客户端-》反向代理层**，通过反向代理层的冗余来实现的。比如两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived

- **反向代理层-》web应用**站点层的冗余来实现的，假设反向代理层是nginx，nginx.conf能够配置多个web后端，并且nginx能够探测到多个后端的存活性。

  自动故障转移，当web-server挂掉了，nginx能够探测到并自动进行故障转移，将流量自动迁移到其他server

- **服务层-》缓存层** 缓存数据的冗余 redis支持主从同步，sentine哨斌机制

- **服务层到数据层** 数据库用主从同步、读写分离

- 读库采用冗余的方式来实现高可用，写库采用keepalived存货探测binlog进行同步



**数据迁移**

1、rdb：SAVE OK 

​     BGSAVE：创建dump.rbd

​     查找dump.rdb位置：CONFIG GET dir

 2、AOF 配置文件打开appendonly yes

3、挂redis从库复制数据方法  redis提供了replication功能可以自动实现同步的过程

配置方法 通过配置文件 从数据库的配置文件加入 slaveof master-ip master-port 主数据库无需配置通过命令行参数启动redis-server，使用-slaveof master port redis-server -port当前数据库停止接收其他数据库的同步，转成redis数据库，程序链接地址都改新的redis库Ip地址和端口

## 15.3 Sentinel（解决宕机）

sentinel：主从之间的切换（自动高可用）cluster用于分散hash负载均衡

案例：服务灾备故障转移 sentinel配置

- redis主从复制将主节点数据同步给从节点，从节点：从节点作为主节点的备份可以随时顶上去；扩展主节点的读能力，分担主节点的读压力

  有问题！主节点宕机，从节点成为master后，同时需要修改应用的主节点地址，还需要命令所有从节点去复制新的主节点

- redis主节点挂掉后

  `slaveof no one` 

  `slaveof 新host 新节点`

- 开启sentinel配置 

  ```
  sentinel monitor mymaster 127.0.0.1 6379 1 mymaster这个主服务器失效至少需要1个sentinel同意
  sentinel down-after-milliseconds mymaster 10000 指定sentinel认为服务器已经断线所需要的时间
  sentinel failover-timeout mymaster 60000 当前sentinel 认为failover失败
  sentinel parallel-sync mymaster 1 指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步
  ```

  

### 15.3.1 sentinel 任务

- monitor ：检查主服务器和从服务器是否运作正常
- notification：当被监控的某个redis服务器出现问题时，sentinel可以通过API向管理员或者其他应用程序发送通知
- Automatic failover：当一个主服务器不能正常工作时，sentinel 会开始一次自动故障迁移，将失效主服务器的一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；



### 15.3.2 冷备 & 热备

- 冷备

  数据库已经正常关闭的情况下

  优点：快速备份的方法，只需要拷贝文件；低度维护、高度安全

  缺点：单独使用只能提供到“某一时间上”的恢复；实施备份全过程中，数据库必须要做备份不能做其他工作

- 热备

  archivelog mode方式 备份数据库的方法

  优点：备份时间短；备份数据库仍可用

  缺点：若备份不成功，所得结果不可用于时间点的恢复



### 15.3.3 sentinel故障转移

- 主观下线
  - 概念：主观下线（Subjectively down ，SDOWN）指的是单个sentinel 实例对服务器作出的下线判断
  - 特点：
    - 如果一个服务器没有在master-down-after-milliseconds选项做指定的时间内对向他发送PING命令的sentinel返回一个有效回复（valid reply），那么sentinel将这个服务器标记为主观下线
    - 服务器对PING命令的有效回复：+PONG；-LOADING；-MASTERDOWN
- 客观下线
  - 概念
    - 多个sentinel实例对同一个服务器作出SDOWN判断，并且通过SENTINEL is master-down-by-addr命令互相交流后，得出服务器下线判断
  - 特点
    - 从主观下线切换到客观下线状态并咩有使用严格的法定人数算法（strong quorum alogorithm），而是使用了流言协议；sentinel在给定的范围内，从其他的sentinel接收到了足够数量的主服务器下线报告，那么sentinel会将主服务器的状态从主观下线状态改变为客观下线
  - 注意点：
    - 客观下线只适用于主服务器，对于其他类型的redis实例，sentinel在将她们judge为下线前不需要协商。

## 15.4 redis内置高可用集群



15.4.1 一致性hash算法


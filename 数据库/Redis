# 一、概述

Redis 速度非常快的非关系型内存键值数据库，可以存储键和五种不同类型的值之间的映射

redis为单进程单线程模式，采用队列模式将并发访问变为串行访问

键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表，有序集合

# 2、数据类型

| 数据类型    | 值                     | 操作                                                         |
| ----------- | ---------------------- | ------------------------------------------------------------ |
| string      | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作 |
| LIST        | 列表                   | 从两端压入或者弹出元素，对单个或者多个元素进行修剪，只保留一个范围内的元素 |
| SET         | 无序集合               | 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 |
| HASH（map） | 包含键值对的无序散列表 | 添加、获取、移除单个键值对。获取所有键值对 。检查某个键是否存在 |
| ZSET        | 有序集合               | 添加、获取、删除元素。根据分值范围或者成员获取元素 计算一个键的排名 |

## bitmap

通过一个bit位表示某个元素对应的值或者状态，其中key就是对应元素本身（8个bit可以组成一个byte，bitmap本身会极大的节省存储空间



BitMap命令

**SETBIT**：SETBIT key offset value 复杂度：O（1）

对key所存储的值，设置或者清楚指定偏移量上的位（bit）

位的设置或清楚取决于value参数，可以是0或者1

当key不存在时，自动生成一个新的字符串值

字符串会进行伸展（GROWN）以确保它可以将value保存在指定的偏移量上。当字符串进行伸展时，空白位置以0填充

offset参数必须大于或者等于0，<2^ 32（bit映射被限制在512MB之内）

**对使用大的offset的SETBIT操作来说，内存分配可能造成redis服务器被阻塞**

**返回值**：字符串指定偏移量上原来的位（bit）

**底层实现**：long类型数组

应用场景：

1、统计用户在线数目

使用时间作为cachekey，用户id位offset，如果当天活跃过就设置为1，计算某天/月/年的活跃用户：

BITOP operation destkey key [key ...]

说明：对一个或者多个保存二进制的字符串key进行位元操作，并将结果保存到destkey上

BITOP支持AND OR NOT XOR 

2、对十亿数据取top

3、用户签到

# 三、数据结构源码分析

## 1、String

SDS：simple dynamic string ；可以修改；类似于arrayList，有一个字符数组

SDS结构使用泛型定义了好多次，没有用int类型，是因为字符串比较短的时候，len和alloc 可以使用short和byte来表示，Redis为了对内存做极致优化，不同长度的字符串使用不同的结构体来表示



SDS&C字符串

C字符串不满足redis对字符串安全性

效率以及功能方面的要求；C使用了一个长度为N+1的字符数组来表示长度为N的字符串，并且字符数组最后一个元素总是‘\0‘

存在以下问题：

获取字符串长度为o(n)级别的操作，因为c不保存数组的长度，每次都要遍历一遍整个数组；

不能很好的杜绝buffer 溢出问题，如果执行拼接or缩短字符串的操作，在空间不足的情况下，不做扩容，会导致以上问题

c字符串只能保存文本数据



**字符串操作**

过期和SET命令扩展

可以对key设置过期时间，到时间就被自动删除，以此控制缓存的失效时间

SET + EXPIRE =》 SETEX

```c
SETEx key 5 value1
```



**计数**

如果value是一个整数，还可以对他使用INCR进行原子性的自增操作（当多个客户端对同一个key进行操作，也不会导致竞争的情况）

```
SET counter 100
INCR counter
INCRBY counter 50

```

**返回原值的GETSET**

为key设置一个值并返回原值：这对于某一些需要隔一段时间就统计的key很方便设置和查看；例如：系统每当由用户进入的时候用INCR操作一个key，当需要统计的时候可以把这个key使用GETSET命令重新赋值 为0



## 2、list

相当于Java中LinkedList ，不是数组！数组！数组～

因此插入、删除操作非常快；

![截屏2020-07-24 下午6.53.34](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.53.34.png)

![截屏2020-07-24 下午6.52.48](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.52.48.png)

多个listnode通过prev和next指针组成双向链表

![截屏2020-07-24 下午6.54.30](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.54.30.png)

LPUSH和RPUSH 分别向list的左边和右边添加一个元素

LRANGE从list中取出一定范围的元素

LINDEX从list中取出指定下表的元素

**![截屏2020-07-24 下午6.56.47](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.56.47.png)**



list实现队列

队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，确保元素的访问顺序

![截屏2020-07-24 下午6.59.08](/Users/yangxinlin/Desktop/截屏2020-07-24 下午6.59.08.png)

list实现栈



## 3、字典哈希

相当于Java中的HashMap。数组+链表的链地址发解决哈希冲突

![截屏2020-07-24 下午7.08.21](/Users/yangxinlin/Desktop/截屏2020-07-24 下午7.08.21.png)


# 一、索引

## B+Tree原理

### 1、数据结构

B Tree 是平衡树，并且所有叶子结点在同一层；

b+Tree 是基于B Tree 和叶子节点顺序访问指针进行实现，具有BTree 平衡性，并且通过顺序访问指针来提高区间查询效率

在b+Tree中 一个节点中key从左到右非递减排列，如果某个指针的左右相邻key分别是keyi 和 keyi+1，且不为null，则该指针指向节点的所有key大于等于keyi 且小于等于keyi+1；

### 2、操作

查找时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归地在指针所指向的节点进行查找，直到找到叶子节点，然后在叶子节点上进行二分查找，找出key所对应的data

插入、删除会破坏平衡，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性

### 3、与红黑树比较

红黑树等平衡术也可以实现索引，但是文件系统以及数据库系统普遍采用b+Tree作为索引，原因如下：

#### （一）更少的查找次数

平衡树查找操作的时间复杂度和树高h相关，O(h)=O(logdN)，其中d为每个节点的出度

红黑树度为2，而b+Tree的出度一般非常大，所以红黑树的查找次数更多

#### （2）**利用磁盘预读特性**

为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读，预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度非常快并且可以利用预读特性，相邻的节点也能被预先载入。

###  （3）磁盘访问原理

操作系统一般将内存和磁盘分割成固定大小的块，每一块为一页，内存与磁盘以页为单位交换数据，数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全载入一个节点。

如果数据不在同一个磁盘上，那么通常需要移动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取的时间，B+树相对于红黑树有更低的书稿，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，素以b+树更适合磁盘数据的读取



补充：

**红黑树**

红黑树是一棵二叉搜索树，每个节点增加了一个存储记录节点的颜色，可以是RED，可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍

红黑树性质：

1、每个节点颜色不是黑色，就是红色

2、根节点是黑色

3、如果一个节点是红色，那么它的两个子节点就是黑色的

4、对于每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点

 补充：树

普通二叉查找树：非平衡，查找的时间复杂度是O（logN）

B树和b+树

B树出现：B-树就是B树

树又名平衡多路查找树，

1、平衡二叉树最多有两个子树，而B树每个节点可以有多个子树，M阶B树表示该树每个节点最多有M个子树

2、B树每个中间节点有k-1个关键字和k个子树

3、B树所有叶节点都在同一层，并且叶子节点只有关键字，子树与节点的大小比较决定了子树指针所处位置

b+树特点

1、有k个子树的中间节点包括k个元素（b树是k-1个元素），**每个元素不保存数据，只用来索引，所有数据都保存在叶子节点**

2、所有的叶子节点包含了全部元素的信息，及指向含这些记录的指针，且叶子节点本身依关键字的大小子小而大顺序链接

3、所有的中间节点元素都同时存在于于子节点，在子节点元素中是最大（或最小）元素

4、每个叶子节点都存有相邻叶子节点的指针，叶子节点本身依关键字的大小顺序链接

B+树比B树的优点：

1、多阶：单一节点存储更多的元素，使得时间复杂度的logN的底数更大，树更矮，io次数更少

2、层数一致，关键字查询路径长度相同，查询性能稳定

3、只有叶子节点存数据，一次性读取进内存的关键字也会更多

4、叶子节点顺序存储数据，可以利用磁盘顺序IO，减少IO读取次数，读取速度更快

5、叶子节点形成有序链表，便于pre和last的范围查询

# MySQL索引

索引是存储引擎实现的，不是服务器层实现的，所以不同的存储引擎有不同索引

## 1、b+Tree索引

大多数MySQL存储引擎的默认索引类型

因为不再需要全表扫描，只需要对树进行搜索即可，所以查找速度很快

因为b+有序性，除了用于查找还可以用于排序和分组

可以指定多个列作为索引列，多个索引列共同组成键

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找，如果不是按照索引列的顺序查找，则无法使用索引

InnoDB的b+Tree 索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录（聚簇索引）。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引

辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找事，需要先在辅助索引中查找到主键值，然后再到主索引中进行查找

## 2、Hash索引

哈希索引能以O（1）查找，但是失去了有序性：无法用于排序与分组；只支持精确查找，无法用于部分查找和范围查找

InnoDB存储引擎有一个特殊功能“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在b+Tree上再创建一个哈希索引，这样就让B+Tree索引具有哈希索引快速查找的优点

## 3、全文索引

MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是比较是否相等

查找条件使用：**MATCH AGAINST**，而不是where

全文索引使用倒排索引实现，记录着关键词到其所在文档的映射

InnoDB存储引擎在5.6.4版本后也支持全文索引

**倒排索引**

正向索引 是以文档id为主键，文档里面有哪些关键词为内容

倒排索引：以word为主键，word所在多个docId为关键内容的索引，关键单词为索引，倒排列表记录该单词在哪些文档中出现以及出现的位置在哪儿

## 4、空间数据索引

MyISAM支持空间数据索引（R-TREE）用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询

必须使用GIS相关的函数来维护数据

## 索引优化

### 1、独立的列

在进行索引查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引

例如：

```mysql
SELECT id FROM customer WHERE id + 1 = 4；
```

### 2、多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好

```mysql
SELECT file_Id , file_name FROM file
WHERE id =1  AND file_name = 1;
```



### 3、索引列的顺序

让选择性最强的索引列放在前面；

索引的选择性：不重复的索引值和记录总数的比值。最大值为1，此时每个记录都有唯一的索引与之对应。选择性越高，每个记录的区分度越高，查询效率越高

```mysql
SELECT COUNT(DISTINCT staff_Id)/COUNT(*) AS staff_id_selectivety,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivety,
COUNT(*)
FROM payment;

staff_id_selectivety:0.0001
customer_id_selectivety:0.0373
COUNT(*):1609
```

### 4、前缀索引

对于BLOB，TEXT和VARCHAR类型的列，必须使用前缀索引，只索引开始的部分字符

前缀长度的选取需要根据索引选择性来确定

### 5、覆盖索引

覆盖索引是一种辅助索引（辅助索引包含所有需要查询的字段的值，只需要访问这个覆盖索引就可以得倒想要查询的字段的值，而不需要再访问主键索引（聚集索引）拿到一整行的值

优点：

1、索引通常远小于数据行的大小，因为只由一行的部分字段组成的索引不包含一整行数据，只读取索引能大大减少数据访问量

2、一些存储引擎在内存中缓存索引，而数据依赖由操作系统来缓存，因此，只访问索引可以不使用系统调用

3、对于InnoDB，若辅助索引能够覆盖查询，则无需访问索引

### 聚集索引、辅助索引、组合索引、非聚集索引

聚集索引&非聚集索引

聚集索引：一张表的主键存储在b+树中，同时叶子节点存放表的每一行的数据，叶子节点存储在数据页中（方便磁盘顺序读取）

非聚集索引：叶子节点存储的不是数据，而是指向某个数据块的指针，所以数据块不是按照顺序放的

聚集索引&辅助索引

聚集索引（主键索引）

innoDB存储引擎是索引组织表，即表中的数据按照主键顺序存放，而聚集索引是按照每张表的主键构造一颗B+树，同时叶子节点存放数据——（聚集索引的叶子节点称为数据页）

辅助索引（二级索引）：非主键索引

叶子节点=键值+书签，InnoDB存储引擎的书签就是相应行数据的主键索引值

单列索引&组合索引（复合索引、联合索引）

单列索引：只有一个字段的索引

组合索引：遵循左侧原则，一个查询可以只使用复合索引最左侧的一部分，例如 key index 

### 索引优点

大大减少了服务器需要扫描的数据行数

帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree索引是有序的，可以用于order by 和group by 操作，临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）

将随机I/O变为顺序I/O

### 索引使用条件

对于非常小的表，全表扫比建立索引更高效

对于中到大的表，索引就非常有效

但是对于特大型的表，建立和维护索引的代价将随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地去匹配（分区技术）

### 索引失效

#### 列与列对比

某个表中，有两列（id和a_id） 都建了单独索引

但是

```mysql
select * from test where id = a_id;
```

这种情况不如走全表扫描

#### 存在NULL值条件

设计数据库表的时候，尽力避免NULL值出现，如果非要不可避免的出现NULL值，也要给一个DEFAULT值，数值型可以给0、-1之类的，字符串有时候给空串有问题，就给一个空格或者其他；如果索引列是可空的，是不会给其建立索引的。索引值是少于表的count(*)

#### NOT条件

建立索引时，给每一个索引建立一个条目，如果查询条件为等等值或者范围查询时，索引可以根据查询条件去查找对应的条目。反过来当查询为非时，索引定位就困难了，执行计划此时可能更倾向于全表扫描，这类的查询条件有：`<> ,NOT ,in,not exists`

#### LIKE通配符

当使用模糊搜索时，尽量采用后置的通配符，例如：name||'%'，因为索引时，会从前去匹配索引列，这时候是可以找到的，如果采用前匹配，那么索引就会很麻烦；前匹配情况下，执行计划更倾向于选择全表扫描。后匹配可以走INDEX RANGE SCAN。所以业务设计的时候，尽量考虑模糊搜索的问题，用后置通配符

#### 条件上包括函数

查询条件尽量不要使用列函数，这样时不会索引的，因为索引建立时会和计算后结果不同，无法定位到索引，但是如果索引条件不是对索引列计算，那么依然可以走索引

```mysql
SELECT * FROM test WHERE upper(name) ='xx'; ERROR
SELECT * FROM test WHERE name = uppper(xx); SUCCESS
```

#### 复合索引前导列区分大

当复合索引前导区分小的时候，有INDEX SKIP SCAN，当前导列区分度大，且查后导列的时候，前导列的分裂会非常消耗资源，执行计划还不如全表扫描

#### 数据类型转换

当查询条件存在隐式转换时，索引会失效。

例如：数据库表id为number类型

但是查询时 

```mysql
select * from table where id ='111';
```

Connect By Level 使用 connect by level 不会走索引

#### 谓词运算

和函数运算类似

#### Vistual Index

虚拟索引

```mysql
CREATE index idx_test_id on test(id);
CREATE index idx_test_Id on test(id)nosegment;
例如：
create index idx_test_id on test(id);
create index idx_test_id on test(a)nosegement;
id为普通索引，a为虚拟索引
begin for i in 1.。100000 loop insert into test values(i,i);end loop ;commit;end;
由于第一次执行 数据库对索引结果做了缓存，第二次执行耗时不走索引；虚拟索引话比普通索引快了很多
```

#### Invisible Index（待定）

# 二、查询性能优化

## 使用explain进行分析

Explain用来分析SELECT查询语句

比较重要的字段：

select_type：查询类型，有简单查询，联合查询，子查询等

key：使用的索引

rows：扫描的行数

## 优化数据访问

1、减少请求数据量

​      只返回必要列；尽量不要使用SELECT*

​      只返回必要的行；使用LIMIT限制返回的数据

​      缓存重复查询的数据；使用缓存可以避免在数据库中查询，特别在要查询的数据经常被重复查询时

2、减少服务器端扫描的行数

​     使用索引来覆盖查询

## 重构查询方式

1、切分大查询

一个大查询如果一次性执行的话，可能一次锁住很多数据，占满整个事务日志、耗尽系统资源、阻塞很多小的但很重要的查询

2、分解大链接查询

将一个大链接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联

好处：

​        让缓存更高效；对于链接查询，如果其中一个表发生变化，那么整个查询缓存都无法使用；而分解后的多个查询，即使其中一个表发生变化，对其他表的查询缓存依然可以使用

​        分解成多个单表查询，这些单表查询的结果更可能被用到其他的查询，减少冗余记录的查询

​        减少锁的竞争

​        查询本身效率有所提升



# 三、存储引擎

## InnoDB

实现了四个标准的隔离级别，默认级别是RR，在RR模式下，通过MVCC+Next-keyLocking防止幻影读

主索引是聚簇索引，在索引中保存了数据，从而比年直接读取磁盘，提升查询性能

内部做了很多优化：从磁盘读取数据时采用可预测读，加快读操作并且自动创建的自适应哈希索引，加速插入操作的插入缓冲区；

支持真正的在线**热备份**；

## MyISAM

数据以紧密格式存储；对于只读数据，或者表比较小，可以容忍修复操作，则依然可以使用它

提供了大量的特性，包括压缩表，空间数据索引

不支持事务

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加派他锁。但是在有表读取操作时，也可以往表中插入新的记录（并发插入）

如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘；这种方式在数据库或者主机崩溃时造成索引损坏，需要执行修复

## 比较

InnoDB事务型的，可以使用commit 、rollback

并发：MyISAM支持表级锁，InnoDB还支持行级锁

外键：InnoDB支持外键

备份：InnoDB支持热备份

崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复速度很慢

# 四、数据类型

## 整型

TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT（8，16，24，32，64）位存储空间，一般越小越好

INT（11）的数字规定了交互工具显示字符的个数

## 浮点数

FLOAT DOUBLE 浮点类型，DECIAML：高精度小数类型。CPU原生支持浮点运算，但是不支持DECIMAL类型的计算，因此DECIMAL的计算比浮点类型更高的代价

## 字符串

CHAR（定长）VARCHAR（变长）

VARCHAR：节省空间，只需要存储必要的内容。但是在执行UPDATE时可能会使行比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM会将行拆成不同的片段存储，而InnoDB则需要分裂页来使行放进页内

在进行存储和检索时，会保留VARCHAR末尾的空格

## 时间和日期

DATETIME、TIMESTAMP

# 五、切分

## 水平切分

sharding，将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，sharding是必然选择，可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力

## 垂直切分

将一张表按列切分成多个表，通常是按照列的关系密集程序进行切分，也可以利用垂直切分将经常使用的列和不经常使用的列切分

例如：电商数据库垂直切分为商品数据库，用户数据库

## sharding策略

### 顺序分库分表

按照id顺序分库分表，但要保证id有顺序自增的，而且会导致顺序分布将来的数据库访问会面临某个数据库过多过热的情况

按照时间来分库，一月一存

如果无法保证id是自增的，那么数据会分散在数据库中，这样热点会分散，但是当增加一个数据库时，可能会做数据迁移，代价很大，这里可以运用**一致性Hash**方法进行分库分表，减少数据迁移，并且也能解决热点过于集中的问题。

### 取模分库分表

一般取模：id mod n(n为2的次数)，使得数据分散，不会有某个数据库过热的问题

二次分库时，为了数据迁移方便，一般是按倍数增加。这样对于某个数据库，一半数据迁移到新数据库，对比每次只增加一个库，所有的数据都要大规模变动

### 映射表

使用单独的数据库存储映射关系

### sharding存在的问题

1、事务问题

使用分布式事务

2、连接

将原来的连接分解成多个单表查询，然后在用户程序中连接

3、ID唯一性



#### 跨库join

切分不可避免的问题——切分。

解决方法：分两次查询，在第一次查询结果集中找出关联数据，根据这些id发起第二次请求得到关联数据

#### 跨节点的count、order by、group by以及聚合函数问题

与join问题类似，分别在各个节点上得到结果后在应用程序段进行合并。和join不同的是每个节点可以并行执行，速度比单一要快很多。但是结果集很大，对应用程序内存消耗很大

#### 数据迁移、容量规划、扩容等问题

# 六、复制

## 主从复制

主要设计三个线程：binlog线程，I/O线程，SQL线程

binlog线程：负责将主服务器上的数据更改写到二进制日志中

I/O线程：负责主服务器上读取二进制日志并写入从服务器的中继日志（relay log）

SQL线程：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（replay）

主从同步事件有3种形式：statement、row、mixed

statement：会将对数据库操作的sql语句写入到binlog中；

row：会将每一条数据的变化写到binlog中

mixed：row和statement混合

## 读写分离

主服务器处理写操作以及实时性比较高的读操作，而从服务器处理写操作

优点：

​    主从服务器各司其职，缓解锁的争用

​    从服务器使用MyISAM，提升查询性能 节约系统开销

​    增加冗余，提高可用性

读写分离常用代理模式实现，代理服务器接受读写请求，再决定转发到任意一个服务器















   


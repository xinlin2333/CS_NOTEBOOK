# 一、分布式概念

![截屏2020-07-28 下午8.58.53](/Users/yangxinlin/Desktop/截屏2020-07-28 下午8.58.53.png)

# 二、分布式事务

## 1、定义

事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同点上；

**原因：**

一个是service产生多个节点，另一个是resource产生多个节点。

## 2、分布式事务基础

### CAP

- C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。
- A (可用性)：非故障的节点在**合理的时间**内返回**合理的响应(不是错误和超时的响应)**。***可用性的两个关键一个是合理的时间，一个是合理的响应***。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。
- P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。



### BASE

Basically available :分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。

software state :许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。

Eventually consistent:最终一致是指经过一段时间后，所有节点数据都将会达到一致

# 三、分布式事务解决方案

## 是否要分布式事务

## 2PC

### XA Transaction

![截屏2020-07-28 下午9.09.33](/Users/yangxinlin/Desktop/截屏2020-07-28 下午9.09.33.png)

XA 协议分为两段

第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.

第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。

优点：

 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从

缺点：

单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。

同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。

数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。

## TCC

转自：

[分布式事务]: https://juejin.im/post/5b5a0bf9f265da0f6523913b#heading-18	"分布式事务"

对于TCC的解释:

TCC事务机制相比于上面介绍的XA，解决了其几个缺点: 1.解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。 2.同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。 3.数据一致性，有了补偿机制之后，由业务活动管理器控制一致性

- Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）
- Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。
- Cancel阶段：取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。

对于TCC来说适合一些:

- 强隔离性，严格一致性要求的活动业务。
- 执行时间较短的业务

## 本地消息表

分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试

![img](https://user-gold-cdn.xitu.io/2018/7/27/164d75fd59779f74?imageslim)



## MQ

对本地消息表的一个封装，将本地消息表移动到了MQ内部

基本流程如下: 

第一阶段Prepared消息，会拿到消息的地址。

第二阶段执行本地事务。

第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。消息接受者就能使用这个消息。

如果确认消息失败，在RocketMq Broker中提供了定时扫描没有更新状态的消息，如果有消息没有得到确认，会向消息发送者发送消息，来判断是否提交，在rocketmq中是以listener的形式给发送者，用来处理。

## Soga事务

长事务拆分为**多个本地短事务**，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据**相反顺序一次调用补偿操作**

每个Saga由一系列sub-transaction Ti 组成 每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果,这里的每个T，都是一个本地事务。 可以看到，和TCC相比，**Saga没有“预留 try”动作，它的Ti就是直接提交到库**。

Saga的执行顺序有两种：

T1, T2, T3, ..., Tn

T1, T2, ..., Tj, Cj,..., C2, C1，其中0 < j < n Saga定义了两种恢复策略：

向后恢复，即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。 向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, ..., Tj(失败), Tj(重试),..., Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。

这里要注意的是，在saga模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。



分布式与集群的区别：

1、分布式：以缩短单个任务的执行时间来提升效率

2、集群：提高单位时间内执行的任务数来提升效率

集群是一组协同工作的服务实体，具有扩展性，高可用性；

扩展性：集群的性能不限于单一的服务实体，新的服务实体可以动态地加入到集群，从而增强集群的性能

高可用性：集群通过服务实体冗余使客户端免于轻易遇到out of service的警告。在集群中，同样的服务的可以由多个服务实体提供。



两大能力：

复杂均衡：任务比较均衡地分布到集群环境下的计算和网络资源

错误恢复：



两大技术：

集群地址：由多个服务实体组成，集群客户端通过访问集群的集群地址获取集群内部各服务实体的功能。具有单一集群地址（单一影像）是集群的一个基本特征。

内部通信：
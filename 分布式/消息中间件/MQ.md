# 一、概念

一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，使用消息队列主要是为了**通过异步处理提高系统性能和削峰、降低系统耦合性**

# 二、意义

## 1、异步处理提高系统性能（削峰、减少响应时间）

不使用MQ，用户的请求数据直接写入数据库，在高并发的情况下增数据库的压力，使得响应速度变慢。使用MQ，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从队列中获取数据，异步写入数据库。**由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。**

消息队列很好的削峰-》异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。

如：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击

## 2、降低耦合性

如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小

客户端发送消息到消息队列中去，服务端处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合

**消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。**

**新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计**

**为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。**



## 3、MQ的问题

- **系统可用性降低**：考虑消息丢失，MQ挂掉
- **系统复杂性提高**：保证消息没有被重复消费，处理消息丢失、保证消息传递有序性
- **一致性问题**：真正的消费者没有消费？

## 4、JMS & AMQP

### 4.1JMS

#### 4.1.1 简介

Java message service：**JMS（JAVA Message Service，Java消息服务）API是一个消息服务的标准或者说是规范**

**ActiveMQ 就是基于 JMS 规范实现的。**

#### 4.1.2 两种消息模型

①点到点（P2P）模型

使用**队列（Queue）\**作为消息通信载体；满足\**生产者与消费者模式**，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时

② 发布/订阅（Pub/Sub）模型

使用**主题（Topic）\**作为消息通信载体，类似于\**广播模式**

**在一条消息广播之后才订阅的用户则是收不到该条消息的**。

#### 4.1.3 五种不同的消息正文格式

- StreamMessage -- Java原始值的数据流
- MapMessage--一套名称-值对
- TextMessage--一个字符串对象
- ObjectMessage--一个序列化的 Java对象
- BytesMessage--一个字节的数据流

### 4.2 AMQP

Advanced message queuing Protocol

提供统一消息服务的应用层标准

**高级消息队列协议**（**二进制应用层协议**）：是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS

基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。

**RabbitMQ 就是基于 AMQP 协议实现的。**

### 4.3 JMS&AMQP

| JMS          | AMQP                                    |                                                              |
| ------------ | --------------------------------------- | ------------------------------------------------------------ |
| 定义         | Java API                                | 协议                                                         |
| 跨语言       | 否                                      | 是                                                           |
| 跨平台       | 否                                      | 是                                                           |
| 支持消息类型 | 提供两种消息模型：①Peer-2-Peer;②Pub/sub | 提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分； |
| 支持消息类型 | 支持多种消息类型 ，我们在上面提到过     | byte[]（二进制）                                             |

1. AMQP为消息定义了**线路层（wire-level protocol)协议**，而JMS所定义的API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。
2. 在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。
3. 由于**Exchange 提供的路由算法**，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。

## 5、常见消息队列对比

| 比方向   | 概要                                                         |
| -------- | ------------------------------------------------------------ |
| 吞吐量   | 万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。 |
| 可用性   | 都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 时效性   | RabbitMQ 基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。 |
| 功能支持 | 除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
| 消息丢失 | ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。 |

